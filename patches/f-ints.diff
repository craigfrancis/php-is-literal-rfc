diff --git a/Zend/zend_compile.c b/Zend/zend_compile.c
index dade906f4b89..8c269262649e 100644
--- a/Zend/zend_compile.c
+++ b/Zend/zend_compile.c
@@ -6384,6 +6384,8 @@ static void zend_compile_attributes(HashTable **attributes, zend_ast *ast, uint3
 			zend_string *name = zend_resolve_class_name_ast(el->child[0]);
 			zend_ast_list *args = el->child[1] ? zend_ast_get_list(el->child[1]) : NULL;
 
+			ZSTR_SET_LITERAL(&name);
+
 			uint32_t flags = (CG(active_op_array)->fn_flags & ZEND_ACC_STRICT_TYPES)
 				? ZEND_ATTRIBUTE_STRICT_TYPES : 0;
 			attr = zend_add_attribute(
@@ -6409,6 +6411,8 @@ static void zend_compile_attributes(HashTable **attributes, zend_ast *ast, uint3
 						arg_ast_ptr = &arg_ast->child[1];
 						uses_named_args = 1;
 
+						ZSTR_SET_LITERAL(&attr->args[j].name);
+
 						for (uint32_t k = 0; k < j; k++) {
 							if (attr->args[k].name &&
 									zend_string_equals(attr->args[k].name, attr->args[j].name)) {
@@ -6422,6 +6426,10 @@ static void zend_compile_attributes(HashTable **attributes, zend_ast *ast, uint3
 					}
 
 					zend_const_expr_to_zval(&attr->args[j].value, arg_ast_ptr);
+
+					if (Z_TYPE(attr->args[j].value) == IS_STRING) {
+						ZSTR_SET_LITERAL(&Z_STR(attr->args[j].value));
+					}
 				}
 			}
 		}
@@ -6578,6 +6586,7 @@ void zend_compile_params(zend_ast *ast, zend_ast *return_type_ast, uint32_t fall
 
 		arg_info = &arg_infos[i];
 		arg_info->name = zend_string_copy(name);
+
 		arg_info->type = (zend_type) ZEND_TYPE_INIT_NONE(0);
 
 		if (attributes_ast) {
@@ -6964,6 +6973,7 @@ zend_string *zend_begin_method_decl(zend_op_array *op_array, zend_string *name,
 
 	op_array->scope = ce;
 	op_array->function_name = zend_string_copy(name);
+	ZSTR_SET_LITERAL(&op_array->function_name);
 
 	lcname = zend_string_tolower(name);
 	lcname = zend_new_interned_string(lcname);
@@ -6998,6 +7008,8 @@ static void zend_begin_func_decl(znode *result, zend_op_array *op_array, zend_as
 
 	unqualified_name = decl->name;
 	op_array->function_name = name = zend_prefix_with_ns(unqualified_name);
+	
+	ZSTR_SET_LITERAL(&op_array->function_name);
 	lcname = zend_string_tolower(name);
 
 	if (FC(imports_function)) {
@@ -7244,12 +7256,19 @@ void zend_compile_prop_decl(zend_ast *ast, zend_ast *type_ast, uint32_t flags, z
 						ZSTR_VAL(ce->name), ZSTR_VAL(name), ZSTR_VAL(str));
 				}
 			}
+			if (Z_TYPE(value_zv) == IS_STRING) {
+				ZSTR_SET_LITERAL(&Z_STR(value_zv));
+			}
 		} else if (!ZEND_TYPE_IS_SET(type)) {
 			ZVAL_NULL(&value_zv);
 		} else {
 			ZVAL_UNDEF(&value_zv);
 		}
 
+		if (Z_TYPE(value_zv) == IS_STRING) {
+			ZSTR_SET_LITERAL(&Z_STR(value_zv));
+		}
+
 		info = zend_declare_typed_property(ce, name, &value_zv, flags, doc_comment, type);
 
 		if (attr_ast) {
@@ -7515,6 +7534,7 @@ void zend_compile_class_decl(znode *result, zend_ast *ast, bool toplevel) /* {{{
 		zend_assert_valid_class_name(unqualified_name);
 		name = zend_prefix_with_ns(unqualified_name);
 		name = zend_new_interned_string(name);
+
 		lcname = zend_string_tolower(name);
 
 		if (FC(imports)) {
@@ -8364,11 +8384,20 @@ static bool zend_try_ct_eval_array(zval *result, zend_ast *ast) /* {{{ */
 			}
 		}
 
+		if (Z_TYPE_P(value) == IS_STRING) {
+			ZSTR_SET_LITERAL(&Z_STR_P(value));
+		}
+
 		Z_TRY_ADDREF_P(value);
 
 		key_ast = elem_ast->child[1];
 		if (key_ast) {
 			zval *key = zend_ast_get_zval(key_ast);
+
+			if (Z_TYPE_P(key) == IS_STRING) {
+                ZSTR_SET_LITERAL(&Z_STR_P(key));
+            }
+
 			switch (Z_TYPE_P(key)) {
 				case IS_LONG:
 					zend_hash_index_update(Z_ARRVAL_P(result), Z_LVAL_P(key), value);
@@ -10025,6 +10054,7 @@ zend_op *zend_compile_var(znode *result, zend_ast *ast, uint32_t type, bool by_r
 	uint32_t checkpoint = zend_short_circuiting_checkpoint();
 	zend_op *opcode = zend_compile_var_inner(result, ast, type, by_ref);
 	zend_short_circuiting_commit(checkpoint, result, ast);
+
 	return opcode;
 }
 
diff --git a/Zend/zend_compile.h b/Zend/zend_compile.h
index 76405a3689dc..4b1c225c4110 100644
--- a/Zend/zend_compile.h
+++ b/Zend/zend_compile.h
@@ -698,6 +698,9 @@ struct _zend_execute_data {
 /* convert constant from compile-time to run-time */
 # define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do { \
 		(node).zv = CT_CONSTANT_EX(op_array, (node).constant); \
+		if (Z_TYPE_P((node).zv) == IS_STRING) { \
+		    ZSTR_SET_LITERAL(&Z_STR_P((node).zv)); \
+		} \
 	} while (0)
 
 #else
@@ -712,9 +715,14 @@ struct _zend_execute_data {
 
 /* convert constant from compile-time to run-time */
 # define ZEND_PASS_TWO_UPDATE_CONSTANT(op_array, opline, node) do { \
+        zval *zv; \
 		(node).constant = \
 			(((char*)CT_CONSTANT_EX(op_array, (node).constant)) - \
 			((char*)opline)); \
+        zv = ((zval*)(((char*)(opline)) + (int32_t)(node).constant)); \
+        if (Z_TYPE_P(zv) == IS_STRING) { \
+            ZSTR_SET_LITERAL(&Z_STR_P(zv)); \
+        } \
 	} while (0)
 
 #endif
diff --git a/Zend/zend_operators.c b/Zend/zend_operators.c
index 8fb31f7dbff3..1277d19aab31 100644
--- a/Zend/zend_operators.c
+++ b/Zend/zend_operators.c
@@ -1859,10 +1859,21 @@ ZEND_API zend_result ZEND_FASTCALL concat_function(zval *result, zval *op1, zval
 {
     zval *orig_op1 = op1;
 	zval op1_copy, op2_copy;
-
+    bool literal = false;
+    
 	ZVAL_UNDEF(&op1_copy);
 	ZVAL_UNDEF(&op2_copy);
 
+    /* this is not good, do better */
+	if (UNEXPECTED(
+	    ((Z_TYPE_P(op1) == IS_STRING && ZSTR_IS_LITERAL(Z_STR_P(op1))) && 
+	        ((Z_TYPE_P(op2) == IS_STRING && ZSTR_IS_LITERAL(Z_STR_P(op2))) || Z_TYPE_P(op2) == IS_LONG)) ||
+	    ((Z_TYPE_P(op2) == IS_STRING && ZSTR_IS_LITERAL(Z_STR_P(op2))) && 
+	        ((Z_TYPE_P(op1) == IS_STRING && ZSTR_IS_LITERAL(Z_STR_P(op1))) || Z_TYPE_P(op1) == IS_LONG))
+	)) {
+	    literal = true;
+	}
+
 	do {
 	 	if (UNEXPECTED(Z_TYPE_P(op1) != IS_STRING)) {
 	 		if (Z_ISREF_P(op1)) {
@@ -1956,6 +1967,12 @@ ZEND_API zend_result ZEND_FASTCALL concat_function(zval *result, zval *op1, zval
 		ZSTR_VAL(result_str)[result_len] = '\0';
 	}
 
+    if (literal) {
+        ZSTR_SET_LITERAL(&Z_STR_P(result));
+    } else {
+        ZSTR_UNSET_LITERAL(&Z_STR_P(result));
+    }
+
 	zval_ptr_dtor_str(&op1_copy);
 	zval_ptr_dtor_str(&op2_copy);
 	return SUCCESS;
diff --git a/Zend/zend_string.h b/Zend/zend_string.h
index b0205bd32d48..f4a31a973e17 100644
--- a/Zend/zend_string.h
+++ b/Zend/zend_string.h
@@ -330,6 +330,58 @@ static zend_always_inline void zend_string_release_ex(zend_string *s, bool persi
 	}
 }
 
+#define ZSTR_IS_LITERAL(s)     (GC_TYPE_INFO(s) & (IS_STR_LITERAL|IS_STR_INTERNED))
+
+static zend_always_inline zend_string* zend_string_set_literal(zend_string *s) {
+	if (UNEXPECTED(ZSTR_IS_LITERAL(s))) {
+		return s;
+	}
+
+	if (EXPECTED(GC_REFCOUNT(s) == 1) && !ZSTR_IS_INTERNED(s)) {
+		GC_TYPE_INFO(s) |= IS_STR_LITERAL;
+		return s;
+	}
+
+	zend_string *literal =
+		zend_string_dup(s, GC_FLAGS(s) & IS_STR_PERSISTENT);
+
+	zend_string_release(s);
+
+	GC_TYPE_INFO(literal) |= IS_STR_LITERAL;
+
+	return literal;
+}
+
+static zend_always_inline zend_string* zend_string_unset_literal(zend_string *s) {
+	if (UNEXPECTED(!ZSTR_IS_LITERAL(s))) {
+		return s;
+	}
+
+	if (EXPECTED(GC_REFCOUNT(s) == 1) && !ZSTR_IS_INTERNED(s)) {
+		GC_TYPE_INFO(s) &= ~IS_STR_LITERAL;
+		return s;
+	}
+
+	zend_string *literal =
+		zend_string_dup(s, GC_FLAGS(s) & IS_STR_PERSISTENT);
+
+	zend_string_release(s);
+
+	GC_TYPE_INFO(literal) &= ~IS_STR_LITERAL;
+
+	return literal;
+}
+
+static zend_always_inline void zend_string_set_literal_fast(zend_string *s) {
+	ZEND_ASSERT(GC_REFCOUNT(s) == 1 && !ZSTR_IS_INTERNED(s));
+
+	GC_TYPE_INFO(s) |= IS_STR_LITERAL;
+}
+
+#define ZSTR_SET_LITERAL(s)    *(s) = zend_string_set_literal(*(s))
+#define ZSTR_SET_LITERAL_FAST  zend_string_set_literal_fast
+#define ZSTR_UNSET_LITERAL(s)  *(s) = zend_string_unset_literal(*(s))
+
 #if defined(__GNUC__) && (defined(__i386__) || (defined(__x86_64__) && !defined(__ILP32__)))
 BEGIN_EXTERN_C()
 ZEND_API bool ZEND_FASTCALL zend_string_equal_val(zend_string *s1, zend_string *s2);
diff --git a/Zend/zend_types.h b/Zend/zend_types.h
index 963362222d0e..e94d204d0a5c 100644
--- a/Zend/zend_types.h
+++ b/Zend/zend_types.h
@@ -698,6 +698,7 @@ static zend_always_inline uint32_t zval_gc_info(uint32_t gc_type_info) {
 #define IS_STR_PERSISTENT			GC_PERSISTENT /* allocated using malloc */
 #define IS_STR_PERMANENT        	(1<<8)        /* relives request boundary */
 #define IS_STR_VALID_UTF8           (1<<9)        /* valid UTF-8 according to PCRE */
+#define IS_STR_LITERAL              (1<<10)
 
 /* array flags */
 #define IS_ARRAY_IMMUTABLE			GC_IMMUTABLE
diff --git a/Zend/zend_vm_def.h b/Zend/zend_vm_def.h
index e6a49d1c0d76..09be5b0a36bd 100644
--- a/Zend/zend_vm_def.h
+++ b/Zend/zend_vm_def.h
@@ -408,6 +408,9 @@ ZEND_VM_HANDLER(8, ZEND_CONCAT, CONST|TMPVAR|CV, CONST|TMPVAR|CV, SPEC(NO_CONST_
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (OP2_TYPE & (IS_TMP_VAR|IS_VAR)) {
@@ -415,6 +418,9 @@ ZEND_VM_HANDLER(8, ZEND_CONCAT, CONST|TMPVAR|CV, CONST|TMPVAR|CV, SPEC(NO_CONST_
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -3100,7 +3106,6 @@ ZEND_VM_COLD_CONSTCONST_HANDLER(53, ZEND_FAST_CONCAT, CONST|TMPVAR|CV, CONST|TMP
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = GET_OP1_ZVAL_PTR_UNDEF(BP_VAR_R);
 	op2 = GET_OP2_ZVAL_PTR_UNDEF(BP_VAR_R);
 	if ((OP1_TYPE == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -3132,6 +3137,9 @@ ZEND_VM_COLD_CONSTCONST_HANDLER(53, ZEND_FAST_CONCAT, CONST|TMPVAR|CV, CONST|TMP
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (OP2_TYPE & (IS_TMP_VAR|IS_VAR)) {
@@ -3139,6 +3147,9 @@ ZEND_VM_COLD_CONSTCONST_HANDLER(53, ZEND_FAST_CONCAT, CONST|TMPVAR|CV, CONST|TMP
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -3153,6 +3164,8 @@ ZEND_VM_COLD_CONSTCONST_HANDLER(53, ZEND_FAST_CONCAT, CONST|TMPVAR|CV, CONST|TMP
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if (OP1_TYPE == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -3167,12 +3180,19 @@ ZEND_VM_COLD_CONSTCONST_HANDLER(53, ZEND_FAST_CONCAT, CONST|TMPVAR|CV, CONST|TMP
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if (OP2_TYPE == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+	
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if (OP1_TYPE != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -3209,6 +3229,11 @@ ZEND_VM_COLD_CONSTCONST_HANDLER(53, ZEND_FAST_CONCAT, CONST|TMPVAR|CV, CONST|TMP
 			zend_string_release_ex(op2_str, 0);
 		}
 	} while (0);
+	
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 	FREE_OP1();
 	FREE_OP2();
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
@@ -3242,6 +3267,9 @@ ZEND_VM_HANDLER(54, ZEND_ROPE_INIT, UNUSED, CONST|TMPVAR|CV, NUM)
 				ZVAL_UNDEFINED_OP2();
 			}
 			rope[0] = zval_get_string_func(var);
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[0]);
+			}
 			FREE_OP2();
 			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 		}
@@ -3277,6 +3305,9 @@ ZEND_VM_HANDLER(55, ZEND_ROPE_ADD, TMP, CONST|TMPVAR|CV, NUM)
 				ZVAL_UNDEFINED_OP2();
 			}
 			rope[opline->extended_value] = zval_get_string_func(var);
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[opline->extended_value]);
+			}
 			FREE_OP2();
 			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 		}
@@ -3287,11 +3318,12 @@ ZEND_VM_HANDLER(55, ZEND_ROPE_ADD, TMP, CONST|TMPVAR|CV, NUM)
 ZEND_VM_HANDLER(56, ZEND_ROPE_END, TMP, CONST|TMPVAR|CV, NUM)
 {
 	USE_OPLINE
-	zend_string **rope;
-	zval *var, *ret;
+	zend_string **rope, *result;
+	zval *var;
 	uint32_t i;
 	size_t len = 0;
 	char *target;
+	bool literal = true;
 
 	rope = (zend_string**)EX_VAR(opline->op1.var);
 	if (OP2_TYPE == IS_CONST) {
@@ -3322,21 +3354,30 @@ ZEND_VM_HANDLER(56, ZEND_ROPE_END, TMP, CONST|TMPVAR|CV, NUM)
 				ZVAL_UNDEF(EX_VAR(opline->result.var));
 				HANDLE_EXCEPTION();
 			}
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[opline->extended_value]);
+			}
 		}
 	}
 	for (i = 0; i <= opline->extended_value; i++) {
 		len += ZSTR_LEN(rope[i]);
 	}
-	ret = EX_VAR(opline->result.var);
-	ZVAL_STR(ret, zend_string_alloc(len, 0));
-	target = Z_STRVAL_P(ret);
+
+	result = zend_string_alloc(len, 0);
+	target = ZSTR_VAL(result);
 	for (i = 0; i <= opline->extended_value; i++) {
+		if (literal && !ZSTR_IS_LITERAL(rope[i])) {
+			literal = false;
+		}
 		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
 		target += ZSTR_LEN(rope[i]);
 		zend_string_release_ex(rope[i], 0);
 	}
 	*target = '\0';
-
+	if (literal) {
+		ZSTR_SET_LITERAL_FAST(result);
+	}
+	ZVAL_STR(EX_VAR(opline->result.var), result);
 	ZEND_VM_NEXT_OPCODE();
 }
 
@@ -6124,6 +6165,9 @@ ZEND_VM_COLD_CONST_HANDLER(51, ZEND_CAST, CONST|TMP|VAR|CV, ANY, TYPE)
 			break;
 		case IS_STRING:
 			ZVAL_STR(result, zval_get_string(expr));
+			if (UNEXPECTED(Z_TYPE_P(expr) == IS_LONG)) {
+			    ZSTR_SET_LITERAL(&Z_STR_P(result));
+			}
 			break;
 		default:
 			ZEND_ASSERT(opline->extended_value != _IS_BOOL && "Must use ZEND_BOOL instead");
diff --git a/Zend/zend_vm_execute.h b/Zend/zend_vm_execute.h
index 7fabd5d2673a..e9d62c19ba4b 100644
--- a/Zend/zend_vm_execute.h
+++ b/Zend/zend_vm_execute.h
@@ -4743,6 +4743,9 @@ static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CAST_SPEC_CONST_H
 			break;
 		case IS_STRING:
 			ZVAL_STR(result, zval_get_string(expr));
+			if (UNEXPECTED(Z_TYPE_P(expr) == IS_LONG)) {
+			    ZSTR_SET_LITERAL(&Z_STR_P(result));
+			}
 			break;
 		default:
 			ZEND_ASSERT(opline->extended_value != _IS_BOOL && "Must use ZEND_BOOL instead");
@@ -6465,7 +6468,6 @@ static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = RT_CONSTANT(opline, opline->op1);
 	op2 = RT_CONSTANT(opline, opline->op2);
 	if ((IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -6497,6 +6499,9 @@ static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
@@ -6504,6 +6509,9 @@ static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -6518,6 +6526,8 @@ static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if (IS_CONST == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -6532,12 +6542,19 @@ static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if (IS_CONST != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -6575,6 +6592,10 @@ static ZEND_VM_COLD ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_
 		}
 	} while (0);
 
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 }
@@ -8410,6 +8431,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CONST_TMPVAR_HANDL
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
@@ -8417,6 +8441,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CONST_TMPVAR_HANDL
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -8792,7 +8819,6 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = RT_CONSTANT(opline, opline->op1);
 	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
 	if ((IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -8824,6 +8850,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
@@ -8831,6 +8860,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -8845,6 +8877,8 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if (IS_CONST == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -8859,12 +8893,19 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if (IS_CONST != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -8902,6 +8943,10 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_TMPVAR_
 		}
 	} while (0);
 
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 }
@@ -10760,6 +10805,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CONST_CV_HANDLER(Z
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
@@ -10767,6 +10815,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CONST_CV_HANDLER(Z
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -11142,7 +11193,6 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_CV_HAND
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = RT_CONSTANT(opline, opline->op1);
 	op2 = EX_VAR(opline->op2.var);
 	if ((IS_CONST == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -11174,6 +11224,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_CV_HAND
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
@@ -11181,6 +11234,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_CV_HAND
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -11195,6 +11251,8 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_CV_HAND
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if (IS_CONST == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -11209,12 +11267,19 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_CV_HAND
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if (IS_CONST != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -11252,6 +11317,10 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CONST_CV_HAND
 		}
 	} while (0);
 
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 }
@@ -14836,6 +14905,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_TMPVAR_CONST_HANDL
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
@@ -14843,6 +14915,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_TMPVAR_CONST_HANDL
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -15532,7 +15607,6 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
 	op2 = RT_CONSTANT(opline, opline->op2);
 	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -15564,6 +15638,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
@@ -15571,6 +15648,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -15585,6 +15665,8 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -15599,12 +15681,19 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -15641,6 +15730,11 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CONST_
 			zend_string_release_ex(op2_str, 0);
 		}
 	} while (0);
+
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
 
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
@@ -16256,6 +16350,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HAND
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
@@ -16263,6 +16360,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_TMPVAR_TMPVAR_HAND
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -16952,7 +17052,6 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
 	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
 	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -16984,6 +17083,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
@@ -16991,6 +17093,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -17005,6 +17110,8 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -17019,12 +17126,19 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -17061,6 +17175,11 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_TMPVAR
 			zend_string_release_ex(op2_str, 0);
 		}
 	} while (0);
+
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
 	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
@@ -17930,6 +18049,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_TMPVAR_CV_HANDLER(
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
@@ -17937,6 +18059,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_TMPVAR_CV_HANDLER(
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -18264,7 +18389,6 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HAN
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = _get_zval_ptr_var(opline->op1.var EXECUTE_DATA_CC);
 	op2 = EX_VAR(opline->op2.var);
 	if (((IS_TMP_VAR|IS_VAR) == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -18296,6 +18420,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HAN
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
@@ -18303,6 +18430,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HAN
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -18317,6 +18447,8 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HAN
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -18331,12 +18463,19 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HAN
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if ((IS_TMP_VAR|IS_VAR) != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -18373,6 +18512,11 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_TMPVAR_CV_HAN
 			zend_string_release_ex(op2_str, 0);
 		}
 	} while (0);
+
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 	zval_ptr_dtor_nogc(EX_VAR(opline->op1.var));
 
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
@@ -18965,6 +19109,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CAST_SPEC_TMP_HANDLER(ZEND_OPC
 			break;
 		case IS_STRING:
 			ZVAL_STR(result, zval_get_string(expr));
+			if (UNEXPECTED(Z_TYPE_P(expr) == IS_LONG)) {
+			    ZSTR_SET_LITERAL(&Z_STR_P(result));
+			}
 			break;
 		default:
 			ZEND_ASSERT(opline->extended_value != _IS_BOOL && "Must use ZEND_BOOL instead");
@@ -19454,6 +19601,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_ADD_SPEC_TMP_CONST_HANDLE
 				ZVAL_UNDEFINED_OP2();
 			}
 			rope[opline->extended_value] = zval_get_string_func(var);
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[opline->extended_value]);
+			}
 
 			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 		}
@@ -19464,11 +19614,12 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_ADD_SPEC_TMP_CONST_HANDLE
 static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_END_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
 {
 	USE_OPLINE
-	zend_string **rope;
-	zval *var, *ret;
+	zend_string **rope, *result;
+	zval *var;
 	uint32_t i;
 	size_t len = 0;
 	char *target;
+	bool literal = true;
 
 	rope = (zend_string**)EX_VAR(opline->op1.var);
 	if (IS_CONST == IS_CONST) {
@@ -19499,21 +19650,30 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_END_SPEC_TMP_CONST_HANDLE
 				ZVAL_UNDEF(EX_VAR(opline->result.var));
 				HANDLE_EXCEPTION();
 			}
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[opline->extended_value]);
+			}
 		}
 	}
 	for (i = 0; i <= opline->extended_value; i++) {
 		len += ZSTR_LEN(rope[i]);
 	}
-	ret = EX_VAR(opline->result.var);
-	ZVAL_STR(ret, zend_string_alloc(len, 0));
-	target = Z_STRVAL_P(ret);
+
+	result = zend_string_alloc(len, 0);
+	target = ZSTR_VAL(result);
 	for (i = 0; i <= opline->extended_value; i++) {
+		if (literal && !ZSTR_IS_LITERAL(rope[i])) {
+			literal = false;
+		}
 		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
 		target += ZSTR_LEN(rope[i]);
 		zend_string_release_ex(rope[i], 0);
 	}
 	*target = '\0';
-
+	if (literal) {
+		ZSTR_SET_LITERAL_FAST(result);
+	}
+	ZVAL_STR(EX_VAR(opline->result.var), result);
 	ZEND_VM_NEXT_OPCODE();
 }
 
@@ -19930,6 +20090,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_HANDL
 				ZVAL_UNDEFINED_OP2();
 			}
 			rope[opline->extended_value] = zval_get_string_func(var);
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[opline->extended_value]);
+			}
 			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
 			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 		}
@@ -19940,11 +20103,12 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_ADD_SPEC_TMP_TMPVAR_HANDL
 static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_END_SPEC_TMP_TMPVAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
 {
 	USE_OPLINE
-	zend_string **rope;
-	zval *var, *ret;
+	zend_string **rope, *result;
+	zval *var;
 	uint32_t i;
 	size_t len = 0;
 	char *target;
+	bool literal = true;
 
 	rope = (zend_string**)EX_VAR(opline->op1.var);
 	if ((IS_TMP_VAR|IS_VAR) == IS_CONST) {
@@ -19975,21 +20139,30 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_END_SPEC_TMP_TMPVAR_HANDL
 				ZVAL_UNDEF(EX_VAR(opline->result.var));
 				HANDLE_EXCEPTION();
 			}
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[opline->extended_value]);
+			}
 		}
 	}
 	for (i = 0; i <= opline->extended_value; i++) {
 		len += ZSTR_LEN(rope[i]);
 	}
-	ret = EX_VAR(opline->result.var);
-	ZVAL_STR(ret, zend_string_alloc(len, 0));
-	target = Z_STRVAL_P(ret);
+
+	result = zend_string_alloc(len, 0);
+	target = ZSTR_VAL(result);
 	for (i = 0; i <= opline->extended_value; i++) {
+		if (literal && !ZSTR_IS_LITERAL(rope[i])) {
+			literal = false;
+		}
 		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
 		target += ZSTR_LEN(rope[i]);
 		zend_string_release_ex(rope[i], 0);
 	}
 	*target = '\0';
-
+	if (literal) {
+		ZSTR_SET_LITERAL_FAST(result);
+	}
+	ZVAL_STR(EX_VAR(opline->result.var), result);
 	ZEND_VM_NEXT_OPCODE();
 }
 
@@ -20789,6 +20962,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_ADD_SPEC_TMP_CV_HANDLER(Z
 				ZVAL_UNDEFINED_OP2();
 			}
 			rope[opline->extended_value] = zval_get_string_func(var);
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[opline->extended_value]);
+			}
 
 			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 		}
@@ -20799,11 +20975,12 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_ADD_SPEC_TMP_CV_HANDLER(Z
 static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_END_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
 {
 	USE_OPLINE
-	zend_string **rope;
-	zval *var, *ret;
+	zend_string **rope, *result;
+	zval *var;
 	uint32_t i;
 	size_t len = 0;
 	char *target;
+	bool literal = true;
 
 	rope = (zend_string**)EX_VAR(opline->op1.var);
 	if (IS_CV == IS_CONST) {
@@ -20834,21 +21011,30 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_END_SPEC_TMP_CV_HANDLER(Z
 				ZVAL_UNDEF(EX_VAR(opline->result.var));
 				HANDLE_EXCEPTION();
 			}
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[opline->extended_value]);
+			}
 		}
 	}
 	for (i = 0; i <= opline->extended_value; i++) {
 		len += ZSTR_LEN(rope[i]);
 	}
-	ret = EX_VAR(opline->result.var);
-	ZVAL_STR(ret, zend_string_alloc(len, 0));
-	target = Z_STRVAL_P(ret);
+
+	result = zend_string_alloc(len, 0);
+	target = ZSTR_VAL(result);
 	for (i = 0; i <= opline->extended_value; i++) {
+		if (literal && !ZSTR_IS_LITERAL(rope[i])) {
+			literal = false;
+		}
 		memcpy(target, ZSTR_VAL(rope[i]), ZSTR_LEN(rope[i]));
 		target += ZSTR_LEN(rope[i]);
 		zend_string_release_ex(rope[i], 0);
 	}
 	*target = '\0';
-
+	if (literal) {
+		ZSTR_SET_LITERAL_FAST(result);
+	}
+	ZVAL_STR(EX_VAR(opline->result.var), result);
 	ZEND_VM_NEXT_OPCODE();
 }
 
@@ -21579,6 +21765,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CAST_SPEC_VAR_HANDLER(ZEND_OPC
 			break;
 		case IS_STRING:
 			ZVAL_STR(result, zval_get_string(expr));
+			if (UNEXPECTED(Z_TYPE_P(expr) == IS_LONG)) {
+			    ZSTR_SET_LITERAL(&Z_STR_P(result));
+			}
 			break;
 		default:
 			ZEND_ASSERT(opline->extended_value != _IS_BOOL && "Must use ZEND_BOOL instead");
@@ -32346,6 +32535,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_INIT_SPEC_UNUSED_CONST_HA
 				ZVAL_UNDEFINED_OP2();
 			}
 			rope[0] = zval_get_string_func(var);
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[0]);
+			}
 
 			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 		}
@@ -34242,6 +34434,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_INIT_SPEC_UNUSED_TMPVAR_H
 				ZVAL_UNDEFINED_OP2();
 			}
 			rope[0] = zval_get_string_func(var);
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[0]);
+			}
 			zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
 			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 		}
@@ -36736,6 +36931,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_ROPE_INIT_SPEC_UNUSED_CV_HANDL
 				ZVAL_UNDEFINED_OP2();
 			}
 			rope[0] = zval_get_string_func(var);
+			if (Z_TYPE_P(var) == IS_LONG) {
+			    ZSTR_SET_LITERAL(&rope[0]);
+			}
 
 			ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 		}
@@ -38113,6 +38311,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CAST_SPEC_CV_HANDLER(ZEND_OPCO
 			break;
 		case IS_STRING:
 			ZVAL_STR(result, zval_get_string(expr));
+			if (UNEXPECTED(Z_TYPE_P(expr) == IS_LONG)) {
+			    ZSTR_SET_LITERAL(&Z_STR_P(result));
+			}
 			break;
 		default:
 			ZEND_ASSERT(opline->extended_value != _IS_BOOL && "Must use ZEND_BOOL instead");
@@ -39044,6 +39245,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CV_CONST_HANDLER(Z
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
@@ -39051,6 +39255,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CV_CONST_HANDLER(Z
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -41385,7 +41592,6 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CONST_HAND
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = EX_VAR(opline->op1.var);
 	op2 = RT_CONSTANT(opline, opline->op2);
 	if ((IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -41417,6 +41623,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CONST_HAND
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CONST & (IS_TMP_VAR|IS_VAR)) {
@@ -41424,6 +41633,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CONST_HAND
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -41438,6 +41650,8 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CONST_HAND
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if (IS_CV == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -41452,12 +41666,19 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CONST_HAND
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if (IS_CONST == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if (IS_CV != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -41495,6 +41716,10 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CONST_HAND
 		}
 	} while (0);
 
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 }
@@ -42726,6 +42951,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CV_TMPVAR_HANDLER(
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
@@ -42733,6 +42961,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CV_TMPVAR_HANDLER(
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -44996,7 +45227,6 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HAN
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = EX_VAR(opline->op1.var);
 	op2 = _get_zval_ptr_var(opline->op2.var EXECUTE_DATA_CC);
 	if ((IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -45028,6 +45258,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HAN
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if ((IS_TMP_VAR|IS_VAR) & (IS_TMP_VAR|IS_VAR)) {
@@ -45035,6 +45268,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HAN
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -45049,6 +45285,8 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HAN
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if (IS_CV == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -45063,12 +45301,19 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HAN
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if ((IS_TMP_VAR|IS_VAR) == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if (IS_CV != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -45106,6 +45351,10 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_TMPVAR_HAN
 		}
 	} while (0);
 
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 	zval_ptr_dtor_nogc(EX_VAR(opline->op2.var));
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 }
@@ -47733,6 +47982,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CV_CV_HANDLER(ZEND
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
@@ -47740,6 +47992,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_CONCAT_SPEC_CV_CV_HANDLER(ZEND
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -50103,7 +50358,6 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER
 	zval *op1, *op2;
 	zend_string *op1_str, *op2_str, *str;
 
-
 	op1 = EX_VAR(opline->op1.var);
 	op2 = EX_VAR(opline->op2.var);
 	if ((IS_CV == IS_CONST || EXPECTED(Z_TYPE_P(op1) == IS_STRING)) &&
@@ -50135,6 +50389,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER
 		    size_t len = ZSTR_LEN(op1_str);
 
 			str = zend_string_extend(op1_str, len + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(str) && !ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_UNSET_LITERAL(&str);
+			}
 			memcpy(ZSTR_VAL(str) + len, ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
 			if (IS_CV & (IS_TMP_VAR|IS_VAR)) {
@@ -50142,6 +50399,9 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER
 			}
 		} else {
 			str = zend_string_alloc(ZSTR_LEN(op1_str) + ZSTR_LEN(op2_str), 0);
+			if (ZSTR_IS_LITERAL(op1_str) && ZSTR_IS_LITERAL(op2_str)) {
+				ZSTR_SET_LITERAL_FAST(str);
+			}
 			memcpy(ZSTR_VAL(str), ZSTR_VAL(op1_str), ZSTR_LEN(op1_str));
 			memcpy(ZSTR_VAL(str) + ZSTR_LEN(op1_str), ZSTR_VAL(op2_str), ZSTR_LEN(op2_str)+1);
 			ZVAL_NEW_STR(EX_VAR(opline->result.var), str);
@@ -50156,6 +50416,8 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER
 	}
 
 	SAVE_OPLINE();
+    bool literals = false;
+
 	if (IS_CV == IS_CONST) {
 		op1_str = Z_STR_P(op1);
 	} else if (EXPECTED(Z_TYPE_P(op1) == IS_STRING)) {
@@ -50170,12 +50432,19 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER
 		op2_str = Z_STR_P(op2);
 	} else if (EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {
 		op2_str = zend_string_copy(Z_STR_P(op2));
+
 	} else {
 		if (IS_CV == IS_CV && UNEXPECTED(Z_TYPE_P(op2) == IS_UNDEF)) {
 			ZVAL_UNDEFINED_OP2();
 		}
 		op2_str = zval_get_string_func(op2);
 	}
+
+	if ((ZSTR_IS_LITERAL(op1_str) || Z_TYPE_P(op1) == IS_LONG) &&
+	    (ZSTR_IS_LITERAL(op2_str) || Z_TYPE_P(op2) == IS_LONG)) {
+	    literals = true;
+	}
+
 	do {
 		if (IS_CV != IS_CONST) {
 			if (UNEXPECTED(ZSTR_LEN(op1_str) == 0)) {
@@ -50213,6 +50482,10 @@ static ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL ZEND_FAST_CONCAT_SPEC_CV_CV_HANDLER
 		}
 	} while (0);
 
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(str);
+	}
+
 
 	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
 }
diff --git a/ext/standard/basic_functions.stub.php b/ext/standard/basic_functions.stub.php
index db9b0148c428..b2051e5b3139 100755
--- a/ext/standard/basic_functions.stub.php
+++ b/ext/standard/basic_functions.stub.php
@@ -656,6 +656,7 @@ function nl2br(string $string, bool $use_xhtml = true): string {}
 
 function strip_tags(string $string, array|string|null $allowed_tags = null): string {}
 
+
 /**
  * @param array|string $locales
  * @param string $rest
@@ -1424,6 +1425,8 @@ function is_object(mixed $value): bool {}
 
 function is_scalar(mixed $value): bool {}
 
+function is_literal(mixed $value): bool {}
+
 /** @param string $callable_name */
 function is_callable(mixed $value, bool $syntax_only = false, &$callable_name = null): bool {}
 
diff --git a/ext/standard/basic_functions_arginfo.h b/ext/standard/basic_functions_arginfo.h
index e4ee7fc11220..906da6442922 100644
--- a/ext/standard/basic_functions_arginfo.h
+++ b/ext/standard/basic_functions_arginfo.h
@@ -2087,6 +2087,8 @@ ZEND_END_ARG_INFO()
 
 #define arginfo_is_scalar arginfo_boolval
 
+#define arginfo_is_literal arginfo_boolval
+
 ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_is_callable, 0, 1, _IS_BOOL, 0)
 	ZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)
 	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, syntax_only, _IS_BOOL, 0, "false")
@@ -2797,6 +2799,7 @@ ZEND_FUNCTION(is_string);
 ZEND_FUNCTION(is_array);
 ZEND_FUNCTION(is_object);
 ZEND_FUNCTION(is_scalar);
+ZEND_FUNCTION(is_literal);
 ZEND_FUNCTION(is_callable);
 ZEND_FUNCTION(is_iterable);
 ZEND_FUNCTION(is_countable);
@@ -3452,6 +3455,7 @@ static const zend_function_entry ext_functions[] = {
 	ZEND_FE(is_array, arginfo_is_array)
 	ZEND_FE(is_object, arginfo_is_object)
 	ZEND_FE(is_scalar, arginfo_is_scalar)
+	ZEND_FE(is_literal, arginfo_is_literal)
 	ZEND_FE(is_callable, arginfo_is_callable)
 	ZEND_FE(is_iterable, arginfo_is_iterable)
 	ZEND_FE(is_countable, arginfo_is_countable)
diff --git a/ext/standard/formatted_print.c b/ext/standard/formatted_print.c
index 0990b390d6b2..bab7b44cf83d 100644
--- a/ext/standard/formatted_print.c
+++ b/ext/standard/formatted_print.c
@@ -19,6 +19,7 @@
 #include "ext/standard/head.h"
 #include "php_string.h"
 #include "zend_execute.h"
+#include "zend_exceptions.h"
 #include <stdio.h>
 
 #include <locale.h>
@@ -422,7 +423,7 @@ int php_sprintf_get_argnum(char **format, size_t *format_len) {
  *  - 0 or more: ArgumentCountError is thrown
  */
 static zend_string *
-php_formatted_print(char *format, size_t format_len, zval *args, int argc, int nb_additional_parameters)
+php_formatted_print(char *format, size_t format_len, zval *args, int argc, int nb_additional_parameters, bool literals)
 {
 	size_t size = 240, outpos = 0;
 	int alignment, currarg, adjusting, argnum, width, precision;
@@ -618,6 +619,13 @@ php_formatted_print(char *format, size_t format_len, zval *args, int argc, int n
 
 			/* now we expect to find a type specifier */
 			tmp = &args[argnum];
+
+			/* now we check if we are (still) producing a literal string */
+			if (literals && ((Z_TYPE_P(tmp) != IS_STRING || !ZSTR_IS_LITERAL(Z_STR_P(tmp))) &&
+							 (Z_TYPE_P(tmp) != IS_LONG))) {
+				literals = false;
+			}
+
 			switch (*format) {
 				case 's': {
 					zend_string *t;
@@ -727,6 +735,9 @@ php_formatted_print(char *format, size_t format_len, zval *args, int argc, int n
 	/* possibly, we have to make sure we have room for the terminating null? */
 	ZSTR_VAL(result)[outpos]=0;
 	ZSTR_LEN(result) = outpos;
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(result);
+	}
 	return result;
 
 fail:
@@ -758,17 +769,16 @@ static zval *php_formatted_print_get_array(zend_array *array, int *argc)
 PHP_FUNCTION(sprintf)
 {
 	zend_string *result;
-	char *format;
-	size_t format_len;
+	zend_string *format;
 	zval *args;
 	int argc;
 
 	ZEND_PARSE_PARAMETERS_START(1, -1)
-		Z_PARAM_STRING(format, format_len)
+		Z_PARAM_STR(format)
 		Z_PARAM_VARIADIC('*', args, argc)
 	ZEND_PARSE_PARAMETERS_END();
 
-	result = php_formatted_print(format, format_len, args, argc, 1);
+	result = php_formatted_print(ZSTR_VAL(format), ZSTR_LEN(format), args, argc, 1, ZSTR_IS_LITERAL(format));
 	if (result == NULL) {
 		RETURN_THROWS();
 	}
@@ -780,20 +790,19 @@ PHP_FUNCTION(sprintf)
 PHP_FUNCTION(vsprintf)
 {
 	zend_string *result;
-	char *format;
-	size_t format_len;
+	zend_string *format;
 	zval *args;
 	zend_array *array;
 	int argc;
 
 	ZEND_PARSE_PARAMETERS_START(2, 2)
-		Z_PARAM_STRING(format, format_len)
+		Z_PARAM_STR(format)
 		Z_PARAM_ARRAY_HT(array)
 	ZEND_PARSE_PARAMETERS_END();
 
 	args = php_formatted_print_get_array(array, &argc);
 
-	result = php_formatted_print(format, format_len, args, argc, -1);
+	result = php_formatted_print(ZSTR_VAL(format), ZSTR_LEN(format), args, argc, -1, ZSTR_IS_LITERAL(format));
 	efree(args);
 	if (result == NULL) {
 		RETURN_THROWS();
@@ -817,7 +826,7 @@ PHP_FUNCTION(printf)
 		Z_PARAM_VARIADIC('*', args, argc)
 	ZEND_PARSE_PARAMETERS_END();
 
-	result = php_formatted_print(format, format_len, args, argc, 1);
+	result = php_formatted_print(format, format_len, args, argc, 1, false);
 	if (result == NULL) {
 		RETURN_THROWS();
 	}
@@ -845,7 +854,7 @@ PHP_FUNCTION(vprintf)
 
 	args = php_formatted_print_get_array(array, &argc);
 
-	result = php_formatted_print(format, format_len, args, argc, -1);
+	result = php_formatted_print(format, format_len, args, argc, -1, false);
 	efree(args);
 	if (result == NULL) {
 		RETURN_THROWS();
@@ -874,7 +883,7 @@ PHP_FUNCTION(fprintf)
 
 	php_stream_from_zval(stream, arg1);
 
-	result = php_formatted_print(format, format_len, args, argc, 2);
+	result = php_formatted_print(format, format_len, args, argc, 2, false);
 	if (result == NULL) {
 		RETURN_THROWS();
 	}
@@ -907,7 +916,7 @@ PHP_FUNCTION(vfprintf)
 
 	args = php_formatted_print_get_array(array, &argc);
 
-	result = php_formatted_print(format, format_len, args, argc, -1);
+	result = php_formatted_print(format, format_len, args, argc, -1, false);
 	efree(args);
 	if (result == NULL) {
 		RETURN_THROWS();
diff --git a/ext/standard/string.c b/ext/standard/string.c
index fc43d53ff151..234144a881fe 100644
--- a/ext/standard/string.c
+++ b/ext/standard/string.c
@@ -1144,6 +1144,8 @@ PHPAPI void php_implode(const zend_string *glue, HashTable *pieces, zval *return
 	zend_string  *str;
 	char         *cptr;
 	size_t        len = 0;
+	bool          literals = ZSTR_IS_LITERAL(glue) || (ZSTR_LEN(glue) <= 1 && ZSTR_IS_INTERNED(glue));
+
 	struct {
 		zend_string *str;
 		zend_long    lval;
@@ -1169,6 +1171,9 @@ PHPAPI void php_implode(const zend_string *glue, HashTable *pieces, zval *return
 			len += ZSTR_LEN(ptr->str);
 			ptr->lval = 0;
 			ptr++;
+			if (UNEXPECTED(literals && !ZSTR_IS_LITERAL(Z_STR_P(tmp)))) {
+				literals = false;
+			}
 		} else if (UNEXPECTED(Z_TYPE_P(tmp) == IS_LONG)) {
 			zend_long val = Z_LVAL_P(tmp);
 
@@ -1187,6 +1192,7 @@ PHPAPI void php_implode(const zend_string *glue, HashTable *pieces, zval *return
 			len += ZSTR_LEN(ptr->str);
 			ptr->lval = 1;
 			ptr++;
+			literals = false;
 		}
 	} ZEND_HASH_FOREACH_END();
 
@@ -1219,6 +1225,9 @@ PHPAPI void php_implode(const zend_string *glue, HashTable *pieces, zval *return
 	}
 
 	free_alloca(strings, use_heap);
+	if (UNEXPECTED(literals)) {
+		ZSTR_SET_LITERAL(&str);
+	}
 	RETURN_NEW_STR(str);
 }
 /* }}} */
@@ -5222,7 +5231,15 @@ PHP_FUNCTION(str_repeat)
 	zend_long 		mult;			/* Multiplier */
 	zend_string	*result;		/* Resulting string */
 	size_t		result_len;		/* Length of the resulting string */
+	zval        *input = ZEND_CALL_ARG(execute_data, 1);
+	bool         literals = false;
 
+    /* this is not good, do better */
+	if (UNEXPECTED(Z_TYPE_P(input) == IS_LONG || 
+		(Z_TYPE_P(input) == IS_STRING && ZSTR_IS_LITERAL(Z_STR_P(input))))) {
+ 		literals = true;
+	}
+    
 	ZEND_PARSE_PARAMETERS_START(2, 2)
 		Z_PARAM_STR(input_str)
 		Z_PARAM_LONG(mult)
@@ -5263,6 +5280,10 @@ PHP_FUNCTION(str_repeat)
 
 	ZSTR_VAL(result)[result_len] = '\0';
 
+	if (literals) {
+		ZSTR_SET_LITERAL_FAST(result);
+	}
+
 	RETURN_NEW_STR(result);
 }
 /* }}} */
@@ -5518,6 +5539,7 @@ PHP_FUNCTION(str_pad)
 {
 	/* Input arguments */
 	zend_string *input;				/* Input string */
+	zend_string *pad_string = NULL;
 	zend_long pad_length;			/* Length to pad to */
 
 	/* Helper variables */
@@ -5527,12 +5549,13 @@ PHP_FUNCTION(str_pad)
 	zend_long   pad_type_val = STR_PAD_RIGHT; /* The padding type value */
 	size_t	   i, left_pad=0, right_pad=0;
 	zend_string *result = NULL;	/* Resulting string */
+	bool literals = (ZEND_CALL_NUM_ARGS(execute_data) > 2) && (Z_TYPE_P(ZEND_CALL_ARG(execute_data, 3)) == IS_LONG);
 
 	ZEND_PARSE_PARAMETERS_START(2, 4)
 		Z_PARAM_STR(input)
 		Z_PARAM_LONG(pad_length)
 		Z_PARAM_OPTIONAL
-		Z_PARAM_STRING(pad_str, pad_str_len)
+		Z_PARAM_STR(pad_string)
 		Z_PARAM_LONG(pad_type_val)
 	ZEND_PARSE_PARAMETERS_END();
 
@@ -5542,6 +5565,18 @@ PHP_FUNCTION(str_pad)
 		RETURN_STR_COPY(input);
 	}
 
+	if (pad_string) {
+		pad_str_len = ZSTR_LEN(pad_string);
+		pad_str = ZSTR_VAL(pad_string);
+		if (literals) {
+		    literals = ZSTR_IS_LITERAL(input);
+		} else {
+		    literals = ZSTR_IS_LITERAL(pad_string) && ZSTR_IS_LITERAL(input);   
+		}
+	} else {
+		literals = ZSTR_IS_LITERAL(input);
+	}
+
 	if (pad_str_len == 0) {
 		zend_argument_value_error(3, "must be a non-empty string");
 		RETURN_THROWS();
@@ -5588,6 +5623,10 @@ PHP_FUNCTION(str_pad)
 
 	ZSTR_VAL(result)[ZSTR_LEN(result)] = '\0';
 
+	if (UNEXPECTED(literals)) {
+		ZSTR_SET_LITERAL_FAST(result);
+	}
+
 	RETURN_NEW_STR(result);
 }
 /* }}} */
diff --git a/ext/standard/tests/strings/literals/001.phpt b/ext/standard/tests/strings/literals/001.phpt
new file mode 100644
index 000000000000..3d3c24ffd36a
--- /dev/null
+++ b/ext/standard/tests/strings/literals/001.phpt
@@ -0,0 +1,13 @@
+--TEST--
+Literal Strings
+--ENV--
+TAINTED=string
+--FILE--
+<?php
+var_dump(
+    is_literal("string"),
+    is_literal($_ENV["TAINTED"]));
+?>
+--EXPECT--
+bool(true)
+bool(false)
diff --git a/ext/standard/tests/strings/literals/002.phpt b/ext/standard/tests/strings/literals/002.phpt
new file mode 100644
index 000000000000..c5bc30929c25
--- /dev/null
+++ b/ext/standard/tests/strings/literals/002.phpt
@@ -0,0 +1,16 @@
+--TEST--
+Literal Strings Compile Time Concat
+--FILE--
+<?php
+var_dump(
+    "literal" . "string",
+        is_literal("literal" . "string"),
+     24 . "" . 42,
+        is_literal(24 . "" . 42));
+?>
+--EXPECT--
+string(13) "literalstring"
+bool(true)
+string(4) "2442"
+bool(true)
+
diff --git a/ext/standard/tests/strings/literals/003.phpt b/ext/standard/tests/strings/literals/003.phpt
new file mode 100644
index 000000000000..7bb3958c4e6d
--- /dev/null
+++ b/ext/standard/tests/strings/literals/003.phpt
@@ -0,0 +1,52 @@
+--TEST--
+Literal Strings VM Concat
+--ENV--
+TAINTED=string
+--FILE--
+<?php
+$literal = "literal";
+$string = "string";
+
+$twoFour = 24;
+$fourTwo = 42;
+
+var_dump(
+    $literal . " " . $string,
+        is_literal($literal . $string),
+    $twoFour . "" . $fourTwo,
+        is_literal($twoFour . "" . $fourTwo),
+    "not " . "literal " . $_ENV["TAINTED"],
+        is_literal("not " . "literal " . $_ENV["TAINTED"]),
+     $literal . $string,
+        is_literal($literal . $string),
+     'literal' . 'string',
+        is_literal('literal' . 'string'),
+);
+
+$literal .= $string;
+
+var_dump(
+    $literal,
+        is_literal($literal));
+        
+$literal .= $_ENV["TAINTED"];
+
+var_dump(
+    $literal,
+        is_literal($literal));
+?>
+--EXPECT--
+string(14) "literal string"
+bool(true)
+string(4) "2442"
+bool(true)
+string(18) "not literal string"
+bool(false)
+string(13) "literalstring"
+bool(true)
+string(13) "literalstring"
+bool(true)
+string(13) "literalstring"
+bool(true)
+string(19) "literalstringstring"
+bool(false)
diff --git a/ext/standard/tests/strings/literals/004.phpt b/ext/standard/tests/strings/literals/004.phpt
new file mode 100644
index 000000000000..4cd445311274
--- /dev/null
+++ b/ext/standard/tests/strings/literals/004.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Literal Strings VM Rope
+--ENV--
+TAINTED=string
+--FILE--
+<?php
+$literal = "literal";
+$string = "string";
+
+$twoFour = 24;
+$fourTwo = 42;
+
+var_dump(
+    "{$literal} {$string}",
+        is_literal("{$literal} {$string}"),
+    "{$twoFour} {$fourTwo}",
+        is_literal("{$twoFour} {$fourTwo}"),
+    "not {$literal} {$_ENV["TAINTED"]}",
+        is_literal("not {$literal} {$_ENV["TAINTED"]}")
+);
+?>
+--EXPECT--
+string(14) "literal string"
+bool(true)
+string(5) "24 42"
+bool(true)
+string(18) "not literal string"
+bool(false)
diff --git a/ext/standard/tests/strings/literals/005.phpt b/ext/standard/tests/strings/literals/005.phpt
new file mode 100644
index 000000000000..47625787a7c6
--- /dev/null
+++ b/ext/standard/tests/strings/literals/005.phpt
@@ -0,0 +1,64 @@
+--TEST--
+Literal Strings Format
+--DESCRIPTION--
+Formatted prints are allowed to produce literals if is_literal
+would return true for all arguments
+--ENV--
+TAINTED=string
+--FILE--
+<?php
+$allow = [
+    "s" => "string",
+    "d" => 1,
+    "u" => 1,
+    "e" => 1,
+    "c" => 1,
+    "o" => 1,
+    "x" => 1,
+    "X" => 1,
+    "b" => 1
+];
+
+$disallow = [
+    "s" => $_ENV["TAINTED"],
+    "d" => 1.1,
+    "u" => 1.1,
+    "e" => 1.1,
+    "c" => 1.1,
+    "o" => 1.1,
+    "x" => 1.1,
+    "X" => 1.1,
+    "b" => 1.1 
+];
+
+foreach ($allow as $spec => $value) {
+    var_dump(
+        is_literal(
+            sprintf("%{$spec}", $value)));
+}
+
+foreach ($disallow as $spec => $value) {
+    var_dump(
+        is_literal(
+            sprintf("%{$spec}", $value)));
+}
+?>
+--EXPECT--
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+bool(false)
diff --git a/ext/standard/tests/strings/literals/006.phpt b/ext/standard/tests/strings/literals/006.phpt
new file mode 100644
index 000000000000..bd6cd2d3bfa1
--- /dev/null
+++ b/ext/standard/tests/strings/literals/006.phpt
@@ -0,0 +1,16 @@
+--TEST--
+Literal Strings in Constant Arrays
+--FILE--
+<?php
+$array = ['aa' => 'aa', 'bb' => 'bb', 'cc' => 'cc'];
+
+foreach ($array as $k => $v)
+    var_dump(is_literal($k), is_literal($v));
+?>
+--EXPECT--
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
diff --git a/ext/standard/tests/strings/literals/007.phpt b/ext/standard/tests/strings/literals/007.phpt
new file mode 100644
index 000000000000..cff5b8c27442
--- /dev/null
+++ b/ext/standard/tests/strings/literals/007.phpt
@@ -0,0 +1,16 @@
+--TEST--
+Literal Strings in Non Constant Arrays
+--ENV--
+TAINTED=string
+--FILE--
+<?php
+$array = ['aa' => 'aa', 'bb' => sprintf($_ENV["TAINTED"])];
+
+foreach ($array as $k => $v)
+    var_dump(is_literal($k), is_literal($v));
+?>
+--EXPECT--
+bool(true)
+bool(true)
+bool(true)
+bool(false)
diff --git a/ext/standard/tests/strings/literals/008.phpt b/ext/standard/tests/strings/literals/008.phpt
new file mode 100644
index 000000000000..a0764fa3e40d
--- /dev/null
+++ b/ext/standard/tests/strings/literals/008.phpt
@@ -0,0 +1,59 @@
+--TEST--
+Literal Strings in Class Declarations
+--FILE--
+<?php
+#[\Bar("parameter")]
+class Foo {
+    const LITERAL = "LITERAL";
+    static $PROPERTY = "STRING"; 
+    
+    public function method($qux) {}
+}
+
+$reflector = new ReflectionClass(Foo::class);
+
+var_dump(
+    $reflector->getName(),
+        is_literal($reflector->getName()));
+
+foreach ($reflector->getAttributes() as $attribute) {
+    $parameters = $attribute->getArguments();
+    
+    var_dump(
+        $attribute->getName(),
+            is_literal($attribute->getName()));
+
+    foreach ($parameters as $parameter => $value) {
+        var_dump(
+            $value,
+            is_literal($value));
+    }
+}
+
+$reflector = new ReflectionMethod(Foo::class, "method");
+
+foreach ($reflector->getParameters() as $parameter) {
+    var_dump(
+        $parameter->getName(),
+        is_literal($parameter->getName()));
+}
+
+var_dump(
+    FOO::LITERAL,
+        is_literal(FOO::LITERAL),
+    Foo::$PROPERTY,
+        is_literal(FOO::$PROPERTY));
+?>
+--EXPECT--
+string(3) "Foo"
+bool(true)
+string(3) "Bar"
+bool(true)
+string(9) "parameter"
+bool(true)
+string(3) "qux"
+bool(true)
+string(7) "LITERAL"
+bool(true)
+string(6) "STRING"
+bool(true)
diff --git a/ext/standard/tests/strings/literals/009.phpt b/ext/standard/tests/strings/literals/009.phpt
new file mode 100644
index 000000000000..6b172d46e744
--- /dev/null
+++ b/ext/standard/tests/strings/literals/009.phpt
@@ -0,0 +1,42 @@
+--TEST--
+Literal Strings in Function Declarations
+--FILE--
+<?php
+#[\Bar("parameter")]
+function foo($qux) {}
+
+$reflector = new ReflectionFunction('foo');
+
+var_dump(
+    $reflector->getName(), 
+        is_literal($reflector->getName()));
+
+foreach ($reflector->getAttributes() as $attribute) {
+    $parameters = $attribute->getArguments();
+    
+    var_dump(
+        $attribute->getName(),
+            is_literal($attribute->getName()));
+
+    foreach ($parameters as $parameter => $value) {
+        var_dump(
+            $value,
+            is_literal($value));
+    }
+}
+
+foreach ($reflector->getParameters() as $parameter) {
+    var_dump(
+        $parameter->getName(),
+        is_literal($parameter->getName()));
+}
+?>
+--EXPECT--
+string(3) "foo"
+bool(true)
+string(3) "Bar"
+bool(true)
+string(9) "parameter"
+bool(true)
+string(3) "qux"
+bool(true)
diff --git a/ext/standard/tests/strings/literals/010.phpt b/ext/standard/tests/strings/literals/010.phpt
new file mode 100644
index 000000000000..ef6c9bd9c265
--- /dev/null
+++ b/ext/standard/tests/strings/literals/010.phpt
@@ -0,0 +1,42 @@
+--TEST--
+Literal Strings in Symbols
+--FILE--
+<?php
+#[Foo(Foo::class)]
+class Foo {
+    public $baz;
+
+    public function bar(string $arg) {}
+}
+
+$class = new ReflectionClass(Foo::class);
+
+var_dump(
+    is_literal($class->getName()));
+    
+$attributes = $class->getAttributes();
+
+var_dump(
+    is_literal($attributes[0]->getName()));
+
+$properties = $class->getProperties();
+
+var_dump(
+    is_literal($properties[0]->getName()));
+
+$method = $class->getMethod("bar");
+
+var_dump(
+    is_literal($method->getName()));
+
+$arguments = $method->getParameters();
+
+var_dump(
+    is_literal($arguments[0]->getName()));
+?>
+--EXPECT--
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+bool(true)
diff --git a/ext/standard/tests/strings/literals/011.phpt b/ext/standard/tests/strings/literals/011.phpt
new file mode 100644
index 000000000000..feaeafcb22b9
--- /dev/null
+++ b/ext/standard/tests/strings/literals/011.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Literal Strings implode
+--FILE--
+<?php
+var_dump(
+    is_literal(
+        implode("\t", [1,2,3])));
+var_dump(
+    is_literal(
+        implode("\t", ["Hello", "World"])));
+var_dump(
+    is_literal(
+        implode(["Hello", "World"])));
+?>
+--EXPECT--
+bool(true)
+bool(true)
+bool(true)
diff --git a/ext/standard/tests/strings/literals/013.phpt b/ext/standard/tests/strings/literals/013.phpt
new file mode 100644
index 000000000000..6b4049bd41fb
--- /dev/null
+++ b/ext/standard/tests/strings/literals/013.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Literal Strings str_pad
+--ENV--
+TAINTED=string
+--FILE--
+<?php
+var_dump(
+    is_literal(
+        str_pad($_ENV["TAINTED"], 20)));
+var_dump(
+    is_literal(
+        str_pad("hello", 20)));
+var_dump(
+    is_literal(
+        str_pad("hello", 20, $_ENV["TAINTED"])));
+var_dump(
+    is_literal(
+        str_pad("hello", 20, "pad")));
+var_dump(
+    is_literal(
+        str_pad("hello", 10, 9)));
+?>
+--EXPECT--
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(true)
diff --git a/ext/standard/tests/strings/literals/014.phpt b/ext/standard/tests/strings/literals/014.phpt
new file mode 100644
index 000000000000..5e96fbf5f406
--- /dev/null
+++ b/ext/standard/tests/strings/literals/014.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Literal Strings str_repeat
+--ENV--
+TAINTED=string
+--FILE--
+<?php
+var_dump(
+    is_literal(
+        str_repeat($_ENV["TAINTED"], 2)),
+    is_literal(
+        str_repeat("ab", 2)),
+    is_literal(
+        str_repeat(4, 4)));
+?>
+--EXPECT--
+bool(false)
+bool(true)
+bool(true)
diff --git a/ext/standard/type.c b/ext/standard/type.c
index 93df434fe310..3ceb9965db9f 100644
--- a/ext/standard/type.c
+++ b/ext/standard/type.c
@@ -397,6 +397,23 @@ PHP_FUNCTION(is_scalar)
 }
 /* }}} */
 
+/* {{{ Returns true if value is a literal string */
+PHP_FUNCTION(is_literal)
+{
+	zval *zv;
+
+	ZEND_PARSE_PARAMETERS_START(1, 1)
+		Z_PARAM_ZVAL(zv)
+	ZEND_PARSE_PARAMETERS_END();
+
+	if (Z_TYPE_P(zv) != IS_STRING) {
+	    RETURN_BOOL(Z_TYPE_P(zv) == IS_LONG);
+	}
+
+    RETURN_BOOL(ZSTR_IS_LITERAL(Z_STR_P(zv)));
+}
+/* }}} */
+
 /* {{{ Returns true if var is callable. */
 PHP_FUNCTION(is_callable)
 {
