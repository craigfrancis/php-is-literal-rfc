# Checking for Literal Strings in Rust

The check for a Literal String can be done with a [Procedural Macro](https://doc.rust-lang.org/reference/procedural-macros.html), with a function like syntax; where the contents are checked and replaced at compile time.

- **[First Example](https://github.com/craigfrancis/php-is-literal-rfc/tree/main/others/rust/1.basic-macro)** simply includes a `is_literal_string!()` macro. The example [main.rs](https://github.com/craigfrancis/php-is-literal-rfc/blob/main/others/rust/1.basic-macro/example_project/src/main.rs) shows how developers can use the macro, which is defined in the libraries [lib.rs](https://github.com/craigfrancis/php-is-literal-rfc/blob/main/others/rust/1.basic-macro/example_library/src/lib.rs). The macro uses `syn` to parse the contents, ensures the TokenStream is a UTF-8 string literal (aka `syn::LitStr`), then it simply returns a replacement string.

- **[Second Example](https://github.com/craigfrancis/php-is-literal-rfc/tree/main/others/rust/2.basic-example)** shows how a HTML Templating Engine could be setup so certain function arguments only accept literal strings. The example [main.rs](https://github.com/craigfrancis/php-is-literal-rfc/blob/main/others/rust/2.basic-example/example_project/src/main.rs) shows how developers can provide HTML to the library via `html_add!()`. The library itself is split into two crates, because Procedural Macros need to be compiled before they are used. The first library crate provides the [macro lib.rs](https://github.com/craigfrancis/php-is-literal-rfc/blob/main/others/rust/2.basic-example/example_library_macro/src/lib.rs) which developers use to send their HTML to the library. The macro does the same checks as above, but instead of simply returning a string, it calls a function from the second library crate, [backend lib.rs](https://github.com/craigfrancis/php-is-literal-rfc/blob/main/others/rust/2.basic-example/example_library_backend/src/lib.rs) which accepts snippets of HTML code that should only come from the developer (i.e. needs to be a developer defined string).

- **[Third Example](https://github.com/craigfrancis/php-is-literal-rfc/tree/main/others/rust/3.nom-example)** was created by [Geoffroy Couprie](https://geoffroycouprie.com/), who showed how the literal-string check can be done with an example that integrates with the [nom](https://docs.rs/nom/) parser combinator library. For libraries that need to parse/unparse values, nom makes the process much easier.

As noted on [https://eiv.dev](https://eiv.dev), user values must be provided separately. It's up to well tested libraries to incorporate user values into strings like HTML, where the library must do the context aware escaping (mistakes are easy). When it comes to SQL, ideally user values will remain separate (parameterised queries). The exception is when the HTML itself is a user provided value (e.g. from a WYSIWYG editor), that's a different and very complex problem, where the task is removing all unsafe content (e.g.  `<script>`, `<a href="javascript:alert();">link</a>`, `<img src="/" onerror="alert();">`); in which case, see [DOMPurify](https://github.com/cure53/DOMPurify), and hopefully one day the [Sanitizer API](https://github.com/WICG/sanitizer-api).